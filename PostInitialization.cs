using System.Text;

namespace Monkeymoto.NativeGenericDelegates
{
    internal static class PostInitialization
    {
        private static void BuildInterfaceDefinition(StringBuilder sb, bool isAction, int argumentCount)
        {
            string? qualifiedTypeParameters;
            string? returnType;
            string? type;
            string? typeParameters;
            string? antiConstraints;
            bool hasGenericMethods = true;
            if (isAction)
            {
                returnType = "void";
                type = Constants.CategoryAction;
                antiConstraints = Constants.Actions.AntiConstraints[argumentCount];
                if (argumentCount != 0)
                {
                    qualifiedTypeParameters = $"<{Constants.Actions.QualifiedTypeParameters[argumentCount]}>";
                    typeParameters = $"<{Constants.Actions.TypeParameters[argumentCount]}";
                }
                else
                {
                    qualifiedTypeParameters = string.Empty;
                    typeParameters = string.Empty;
                    hasGenericMethods = false;
                }
            }
            else
            {
                qualifiedTypeParameters = $"<{Constants.Funcs.QualifiedTypeParameters[argumentCount]}>";
                returnType = "TResult";
                type = Constants.CategoryFunc;
                typeParameters = $"<{Constants.Funcs.TypeParameters[argumentCount]}";
                antiConstraints = Constants.Funcs.AntiConstraints[argumentCount];
            }
            string genericType = $"{type}{typeParameters}";
            if (typeParameters.Length != 0)
            {
                genericType = $"{genericType}>";
                typeParameters = $"{typeParameters}>";
            }
            string fullType = $"INative{type}{typeParameters}";
            string parameters = Constants.Parameters[argumentCount];
            string typeAsArgument = type.ToLower();
            string callingConvention = $",{Constants.NewLineIndent3}CallingConvention callingConvention = CallingConvention.Winapi";
            string genericMethods = hasGenericMethods ?
     $@"
        
        public static {fullType} From{type}<TMarshaller>
        (
            {genericType} {typeAsArgument}{callingConvention}
        )
            where TMarshaller : IMarshaller<TMarshaller>, new()
        {{
            throw new NotImplementedException();
        }}
        
        public static {fullType} FromFunctionPointer<TMarshaller>
        (
            nint functionPtr{callingConvention}
        )
            where TMarshaller : IMarshaller<TMarshaller>, new()
        {{
            throw new NotImplementedException();
        }}" :
                string.Empty;
            _ = sb.Append
            (
$@"    internal interface INative{type}{qualifiedTypeParameters}{antiConstraints}
    {{
        protected object? Target {{ get; }}
        protected MethodInfo Method {{ get; }}
        
        public static {fullType} From{type}
        (
            {genericType} {typeAsArgument}{callingConvention}
        )
        {{
            throw new NotImplementedException();
        }}
        
        public static {fullType} FromFunctionPointer
        (
            nint functionPtr{callingConvention}
        )
        {{
            throw new NotImplementedException();
        }}{genericMethods}

        public nint GetFunctionPointer();
        public {returnType} Invoke({parameters});
        public {genericType} To{type}() =>
            ({genericType})Delegate.CreateDelegate
            (
                typeof({genericType}),
                Target,
                Method
            );
    }}
"
            );
        }

        public static string GetSourceText()
        {
            var source = new StringBuilder
            (
$@"// <auto-generated/>
using System;
using System.Collections;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable enable

namespace {Constants.RootNamespace}
{{
    internal sealed class DefaultMarshaller : IMarshaller<DefaultMarshaller> {{ }}
    
    internal interface IMarshaller<TSelf> where TSelf : IMarshaller<TSelf>
    {{
        protected static virtual CallingConvention? CallingConvention => null;
        protected static virtual MarshalMap? MarshalMap => null;
        protected static virtual MarshalAsAttribute?[]? MarshalParamsAs => null;
        protected static virtual MarshalAsAttribute? MarshalReturnAs => null;
    }}
    "
            );
            for (int i = 0; i < 17; ++i)
            {
                BuildInterfaceDefinition(source.AppendLine(), isAction: true, argumentCount: i);
                BuildInterfaceDefinition(source.AppendLine(), isAction: false, argumentCount: i);
            }
            _ = source.AppendLine
            (
 $@"
    internal sealed class MarshalMap : IEnumerable<KeyValuePair<Type, MarshalAsAttribute>>
    {{
        public MarshalMap() {{ }}
        public void Add(Type key, MarshalAsAttribute value) {{ }}
        IEnumerator<KeyValuePair<Type, MarshalAsAttribute>>
            IEnumerable<KeyValuePair<Type, MarshalAsAttribute>>.GetEnumerator() =>
                throw new NotImplementedException();
        IEnumerator IEnumerable.GetEnumerator() => throw new NotImplementedException();
    }}
}}

namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    internal sealed class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute
    {{
        public string FilePath {{ get; }} = filePath;
        public int Line {{ get; }} = line;
        public int Character {{ get; }} = character;
    }}
}}

#nullable restore"
            );
            return source.ToString();
        }
    }
}
