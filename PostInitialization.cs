using System.Diagnostics;
using System.Text;

namespace Monkeymoto.Generators.NativeGenericDelegates.Generator
{
    internal static class PostInitialization
    {
        private static void BuildInterfaceDefinition(StringBuilder sb, bool isAction, int argumentCount)
        {
            string? marshalReturnAsParameter;
            string? qualifiedTypeParameters;
            string? returnType;
            string? type;
            string? typeParameters;
            switch (isAction)
            {
                case true:
                    marshalReturnAsParameter = "";
                    returnType = "void";
                    type = "Action";
                    if (argumentCount != 0)
                    {
                        qualifiedTypeParameters = $"<{Constants.Actions.QualifiedTypeParameters[argumentCount]}>";
                        typeParameters = $"<{Constants.Actions.TypeParameters[argumentCount]}>";
                    }
                    else
                    {
                        qualifiedTypeParameters = "";
                        typeParameters = "";
                    }
                    break;
                case false:
                    marshalReturnAsParameter = $",{Constants.NewLine}            MarshalAsAttribute? marshalReturnAs = null";
                    qualifiedTypeParameters = $"<{Constants.Funcs.QualifiedTypeParameters[argumentCount]}>";
                    returnType = "TResult";
                    type = "Func";
                    typeParameters = $"<{Constants.Funcs.TypeParameters[argumentCount]}>";
                    break;
                default:
                    throw new UnreachableException();
            }
            string genericType = $"{type}{typeParameters}";
            string parameters = Constants.Parameters[argumentCount];
            string typeAsArgument = type.ToLower();
            string callingConvention =
                $",{Constants.NewLine}            CallingConvention callingConvention = CallingConvention.Winapi";
            string marshalParamsAsParameter = argumentCount == 0 ?
                "" :
                $",{Constants.NewLine}            MarshalAsAttribute?[]? marshalParamsAs = null";
            _ = sb.Append
            (
$@"    internal interface INative{type}{qualifiedTypeParameters}
    {{
        public static INative{genericType} From{type}
        (
            {genericType} {typeAsArgument}{marshalReturnAsParameter}{marshalParamsAsParameter}{callingConvention}
        )
        {{
            throw new NotImplementedException();
        }}

        public static INative{genericType} FromFunctionPointer
        (
            nint functionPtr{marshalReturnAsParameter}{marshalParamsAsParameter}{callingConvention}
        )
        {{
            throw new NotImplementedException();
        }}

        public nint GetFunctionPointer();
        public {returnType} Invoke({parameters});
        public {genericType} To{type}() => Invoke;
    }}
"
            );
        }

        public static string GetSource()
        {
            var source = new StringBuilder
            (
$@"// <auto-generated/>
using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable enable

namespace {Constants.RootNamespace}
{{"
            );
            for (int i = 0; i < 17; ++i)
            {
                BuildInterfaceDefinition(source.AppendLine(), isAction: true, argumentCount: i);
                BuildInterfaceDefinition(source.AppendLine(), isAction: false, argumentCount: i);
            }
            _ = source.AppendLine
            (
$@"
}}

namespace System.Runtime.CompilerServices
{{
    [AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]
    internal sealed class InterceptsLocationAttribute(string filePath, int line, int character) : Attribute
    {{
        public string FilePath {{ get; }} = filePath;
        public int Line {{ get; }} = line;
        public int Character {{ get; }} = character;
    }}
}}

#nullable restore"
            );
            return source.ToString();
        }
    }
}
